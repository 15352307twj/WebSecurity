# WebSecurity-DES
Implementation of Data Encryption Standard (DES) in C

## 一、算法原理概述

### 1. 什么是对称加密算法

> 对称密码算法有时又叫传统密码算法、秘密密钥算法或单密钥算法。对称密码算法的加密密钥能够从解密密钥中推算出来，反过来也成立。在大多数对称算法中，加密解密密钥是相同的。它要求发送者和接收者在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都能对消息进行加密解密。只要通信需要保密，密钥就必须保密。

### 2. 对称密码常用的数学运算
对称密码当中有几种常用到的数学运算。这些运算的共同目的就是把被加密的明文数码尽可能深地打乱，从而加大破译的难度。

>   ◆移位和循环移位  
　　移位就是将一段数码按照规定的位数整体性地左移或右移。循环右移就是当右移时，把数码的最后的位移到数码的最前头，循环左移正相反。例如，对十进制数码12345678循环右移1位（十进制位）的结果为81234567，而循环左移1位的结果则为23456781。    
◆置换  
　　就是将数码中的某一位的值根据置换表的规定，用另一位代替。它不像移位操作那样整齐有序，看上去杂乱无章。这正是加密所需,被经常应用。    
◆扩展  
　　就是将一段数码扩展成比原来位数更长的数码。扩展方法有多种,例如,可以用置换的方法，以扩展置换表来规定扩展后的数码每一位的替代值。    
◆压缩  
　　就是将一段数码压缩成比原来位数更短的数码。压缩方法有多种，例如，也可以用置换的方法，以表来规定压缩后的数码每一位的替代值。    
◆异或  
　　这是一种二进制布尔代数运算。异或的数学符号为⊕ ，可以简单地理解为，参与异或运算的两数位如相等，则结果为0，不等则为1。    
◆迭代  
　　迭代就是多次重复相同的运算，这在密码算法中经常使用，以使得形成的密文更加难以破解。


### 3.DES算法简介
DES是Data Encryption Standard（数据加密标准）的缩写。它是由IBM公司研制的一种对称密码算法，美国国家标准局于1977年公布把它作为非机要部门使用的数据加密标准，三十年来，它一直活跃在国际保密通信的舞台上，扮演了十分重要的角色。

DES是一个分组加密算法，典型的DES以64位为分组对称数据加密，加密和解密用的是同一个算法。它的密钥长度是56位（因为每个第8 位都用作奇偶校验），密钥可以是任意的56位的数，而且可以任意时候改变。其中有极少数被认为是易破解的弱密钥，但是很容易避开它们不用。所以保密性依赖于密钥。

DES加密的算法框架如下：

> 首先要生成一套加密密钥，从用户处取得一个64位长的密码口令，然后通过等分、移位、选取和迭代形成一套16个加密密钥，分别供每一轮运算中使用。
> 
> DES对64位(bit)的明文分组M进行操作，M经过一个初始置换IP，置换成m0。将m0明文分成左半部分和右半部分m0 = (L0，R0)，各32位长。然后进行16轮完全相同的运算（迭代），这些运算被称为函数f，在每一轮运算过程中数据与相应的密钥结合。
> 
> 在每一轮中，密钥位移位，然后再从密钥的56位中选出48位。通过一个扩展置换将数据的右半部分扩展成48位，并通过一个异或操作替代成新的48位数据，再将其压缩置换成32位。这四步运算构成了函数f。然后，通过另一个异或运算，函数f的输出与左半部分结合，其结果成为新的右半部分，原来的右半部分成为新的左半部分。将该操作重复16次。
> 
> 经过16轮迭代后，左，右半部分**互换**，然后合在一起经过一个末置换（数据整理），这样就完成了加密过程。

加密流程图：  
![DES加密算法框架][1]　

DES有一个非常有用的性质：加密和解密使用相同的算法！DES加密和解密唯一的不同是密钥的次序相反。如果各轮加密密钥分别是K1，K2，K3…K16，那么解密密钥就是K16，K15，K14…K1。这也就是DES被称为对称算法的理由。

---

## 二、总体结构

根据流程图的结构，按顺序简单介绍一下各部分。

### 1. 初始置换 Initial Permutation
初始置换这部分很简单，只是一个置换表。将明文中的某一位的值根据置换表的规定，用另一位代替。如以下置换表，将第57位放到第0位，第49位放到第1位......
```
// 初始置换 Initial Permutation
int IP_table[64] = {57, 49, 41, 33, 25, 17, 9, 1,  
	                59, 51, 43, 35, 27, 19, 11, 3,  
	                61, 53, 45, 37, 29, 21, 13, 5,  
	                63, 55, 47, 39, 31, 23, 15, 7,  
	                56, 48, 40, 32, 24, 16, 8, 0,  
	                58, 50, 42, 34, 26, 18, 10, 2,  
	                60, 52, 44, 36, 28, 20, 12, 4,  
	                62, 54, 46, 38, 30, 22, 14, 6};
```

### 2. 子密钥Ki获取
获取子密钥Ki的流程图  
![获取子密钥Ki的流程图][2]

> 1. 用户输入的密钥是 64 位的，根据密钥置换表PC1，将 64 位变成 56 位密钥。（去掉了8位奇偶校验位，分别是8, 16, ... , 64位）
> 2. 将 PC1 置换得到的 56 位密钥，分为前28位 C0 和后28位 D0，分别对它们进行循环左移，C0左移得到 C1，D0 左移得到D1。
> 3. 将 C1 和 D1 合并成 56 位，然后通过PC2表进行压缩置换，得到当前这一轮的 48 位子密钥 K1 。
> 4. 然后对 C1 和 D1 进行左移和压缩置换，获取下一轮的子密钥……一共进行16轮，得到 16 个 48 位的子密钥。

相关置换表和循环左移次数如下：
```
// 密钥置换表，将64位密钥变成56位
int PC_1[56] = {56, 48, 40, 32, 24, 16, 8,  
            	0, 57, 49, 41, 33, 25, 17,  
            	9, 1, 58, 50, 42, 34, 26,  
            	18, 10, 2, 59, 51, 43, 35,  
            	62, 54, 46, 38, 30, 22, 14,  
            	6, 61, 53, 45, 37, 29, 21,  
            	13, 5, 60, 52, 44, 36, 28,  
            	20, 12, 4, 27, 19, 11, 3};

// 压缩置换，将56位密钥压缩成48位子密钥
int PC_2[48] = {13, 16, 10, 23, 0, 4, 2, 27,  
        		14, 5, 20, 9, 22, 18, 11, 3,  
        		25, 7, 15, 6, 26, 19, 12, 1,  
        		40, 51, 30, 36, 46, 54, 29, 39,  
        		50, 44, 32, 46, 43, 48, 38, 55,  
        		33, 52, 45, 41, 49, 35, 28, 31};

// 规定每一轮左移的次数
int left_shift[16] = {1, 1, 2, 2, 2, 2, 2, 2, 
					1, 2, 2, 2, 2, 2, 2, 1};
```

### 3. 密码函数f
将加密函数的f密码函数展开来讲。密码函数f(R, K)接受两个读入：数据右32位 以及 48位的子密钥Ki，进行f函数运算，然后与左32位进行异或运算，就变成新的右32位了。（顺带一提，原来的数据右32位变成新的数据的左32位）
![密码函数][3]  
具体步骤：

> 1. 通过表 E 进行扩展置换，将输入的 32 位数据扩展为 48 位；
> 2. 将扩展后的 48 位数据与 48 位的子密钥进行异或运算；
> 3. 将异或得到的 48 位数据分成 8 个 6 位的块，每一个块通过对应的一个 S 表产生一个 4 位的输出。其中，每个 S 表都是 4 行16 列。具体的置换过程如下：
>   - 把 6 位输入中的第 1 位和第 6 位取出来合成一个两位的二进制数 x ，作为 Si 表中的行数（0~3）；
>   - 把 6 位输入的中间 4 位构成另外一个二进制数 y，作为 Si 表的列数（0~15）；
>   - 查出 Si 表中 x 行 y 列所对应的整数，将该整数转换为一个 4 位的二进制数。
> 4. 把通过 S 表置换得到的 8 个 4 位连在一起，形成一个 32 位的数据。然后将该 32 位数据通过表 P 进行置换（称为P-置换），置换后得到一个仍然是 32 位的结果数据，这就是f(R, K)函数的输出。


扩展至换表、P置换表以及S表如下
```
// 扩展置换表
int extend_table[48] = {31, 0, 1, 2, 3, 4,  
                		3, 4, 5, 6, 7, 8,  
                		7, 8, 9, 10, 11, 12,  
                		11, 12, 13, 14, 15, 16,  
                		15, 16, 17, 18, 19, 20,  
                		19, 20, 21, 22, 23, 24,  
                		23, 24, 25, 26, 27, 28,  
                		27, 28, 29, 30, 31, 0};


//8个S表，每个表4行16列
int S[8][4][16] =  
            {	
            // S1
              {{14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7},  
               {0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8},  
               {4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0},  
               {15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13}},  
            // S2  
             {{15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10},  
              {3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5},  
              {0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15},  
              {13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9}},  
            //S3  
             {{10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8},  
              {13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1},  
              {13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7},  
              {1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12}},  
            //S4  
             {{7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15},  
              {13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9},  
              {10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4},  
              {3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14}},  
            //S5  
             {{2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9},  
              {14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6},  
              {4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14},  
              {11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3}},  
            //S6  
             {{12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11},  
              {10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8},  
              {9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6},  
              {4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13}},  
            //S7  
             {{4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1},  
              {13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6},  
              {1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2},  
              {6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12}},  
            //S8  
             {{13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7},  
              {1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2},  
              {7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8},  
              {2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11}}
          };  

//P置换表  
int p_table[32] = {15, 6, 19, 20, 28, 11, 27, 16,  
                  0, 14, 22, 25, 4, 17, 30, 9,  
                  1, 7, 23, 13, 31, 26, 2, 8,  
                  18, 12, 29, 5, 21, 10, 3, 24};  
```

### 4. 逆初始置换 Inverse Initial Permutation
合并 数据左32位 和 数据右32位 得到一个 64 位的数据，再经过逆初始置换后得到的就是 64 位的密文。
```
//逆初始置换表IIP
int IIP_table[64] = {39, 7, 47, 15, 55, 23, 63, 31,  
		           38, 6, 46, 14, 54, 22, 62, 30,  
		           37, 5, 45, 13, 53, 21, 61, 29,  
		           36, 4, 44, 12, 52, 20, 60, 28,  
		           35, 3, 43, 11, 51, 19, 59, 27,  
		           34, 2, 42, 10, 50, 18, 58, 26,  
		           33, 1, 41, 9, 49, 17, 57, 25,  
		           32, 0, 40, 8, 48, 16, 56, 24};  
```
至此，DES算法的总体结构已经按照流程图分析了一遍，此时再看流程图就会大致明白了。接下来就是各个模块的具体实现。

---

## 三、模块分解
介绍模块之前，先来说一说关于模块设计的想法。DES是一种分组对称加密算法，以8个字节为一组，对每一组进行加密计算。当需要加密的信息非常大的时候，就需要进行许多次的加密计算，耗时会很长。为了加快程序的加密速度，应该尽可能地选择如c,c++效率高的语言；此外在程序中，也要尽量少地调用函数，减少传参、保存上下文带来的开销。因此，我在设计模块的时候，在尽量保证程序清晰明了、可读性高的情况下，使用较少的模块，并且每个模块功能明确。以下为四个模块：
```
typedef char Elem;
// 方便日后更换数据类型

void Char2Bit(Elem ch[8], int bit[64]);
void Bit2Char(int bit[64], Elem ch[8]);
// 用来处理8字节和64位之间的转换

int file_rw(char *inFile, char *outFile, char *keyText, int isDecode); 
// 负责读入文件名为inFile的文本信息，isDecode表示加密/解密，利用密码keyText进行加密/解密，结果输出到文件名为outFile的文件中

void CreateSubKey(int key[64], int subKeys[16][48]);
// 读入64位密钥，生成16个子密钥

void CryptologyBlock(Elem in[8], Elem out[8], int subKeys[16][48], int isDecode);
// 分组进行加密/解密，读入8字节文本in，根据isDecode并结合16Ge 子密钥subKeys[16]对其进行加密/解密，输出8字节文本out

void f (int right[32], int subkey[48]);
// 密码函数f，接受两个输入：数据右32位right 以及 48位的子密钥Ki subkey，结果返回到right中
```
具体实现请看下面源代码。

---

## 四、C语言源代码
```
#include <stdio.h>
#include <string.h>
#include "table.h"

// 使用typedef绑定数据类型
typedef char Elem;

//------------------二进制位串 和 字符串 的相互转换-------------------------
void Char2Bit(Elem ch[8], int bit[64]) {
	int i, j;
	for (i = 0; i < 8; i++)
		for (j = 0; j < 8; j++)
			bit[8 * (i + 1) - (j + 1)] = (ch[i] >> j) & 1;
}

void Bit2Char(int bit[64], Elem ch[8]) {
	int i, j;
	for (i = 0; i < 8; i++)
		for (j = 0; j < 8; j++)
			ch[i] = (ch[i] << 1) + bit[8 * i + j];
}


//--------------------------16个子密钥生成-------------------------------
void CreateSubKey(int key[64], int subKeys[16][48]) {
	int data[56]; // 用于存储56位数据
	int i = 0;

	// PC1置换
	for (i = 0; i < 56; i++)
		data[i] = key[PC_1[i]];

	// 生成16个子密钥
	for (i = 0; i < 16; i++) {
		int j;

		// 左移
		int time = left_shift[i],
		    temp1[2] = {data[0], data[1]}, 
		    temp2[2] = {data[28], data[29]}; 
		for (j = 0; j < 28 - time; j++) {
			data[j] = data[j + time];
			data[28 + j] = data[28 + j + time];
		}
		for (j = 1; j <= time; j++) {
			data[28 - j] = temp1[time - j];
			data[56 - j] = temp2[time - j];
		}

		// PC2置换
		for (j = 0; j < 48; j++)
			subKeys[i][j] = data[PC_2[j]];
	}
}

//------------------------密码函数f--------------------------------

void f (int right[32], int subkey[48]) {
	// 右32位进行扩展 & 异或运算
	int i;
	int extend[48];
	for (i = 0; i < 48; i++)
		extend[i] = (right[extend_table[i]] ^ subkey[i]);

	/* 分成8个6位块，通过S表产生4位输出，共32位
	把6位输入中的第1, 6位取出来合成一个两位的二进制数 x ，作为行数（0~3）；
	把6位输入的中间4位构成另外一个二进制数 y，作为列数（0~15）；
	查出 Si 表中 x 行 y 列所对应的整数，将该整数转换为一个 4 位的二进制数。
	*/
	int temp[32];
	int x, y, row, col, target;
	for (i = 0; i < 8; i++) {
		x = 6 * i;
		row = (extend[x] << 1) + extend[x + 5];
		col = (extend[x + 1] << 3) 
				+ (extend[x + 2] << 2)
				+ (extend[x + 3] << 1)
				+ extend[x + 4];
		target = S[i][row][col];

		y = 4 * i;
		temp[y] = (target & 8) >> 3;
		temp[y + 1] = (target & 4) >> 2;
		temp[y + 2] = (target & 2) >> 1;
		temp[y + 3] = (target & 1);
	}

	// p置换
	for (i = 0; i < 32; i++)
		right[i] = temp[p_table[i]];
}

//-------------------------分组加密/解密--------------------------------
void CryptologyBlock(Elem in[8], Elem out[8], int subKeys[16][48], int isDecode) {
	int temp[64], inBit[64];
	Char2Bit(in, temp);
	int i;

	
	// IP 初始置换
	for (i = 0; i < 64; i++)
		inBit[i] = temp[IP_table[i]];

	// 分成左右各32位，进行16次迭代
	int left[32], right[32], swap[32];
	for (i = 0; i < 32; i++) {
		left[i] = inBit[i];
		right[i] = inBit[32 + i];
	}

	for (i = 0; i < 16; i++) {
		// right = f(right, subKeys[i]) xor left
		// left = right
		int j;
		for (j = 0; j < 32; j++)
			swap[j] = right[j];

		// 根据需求：加密/解密，确定使用哪一个子密钥
		int index;
		index = (isDecode == 0) ? i : (15 - i);
		f(right, subKeys[index]);

		for (j = 0; j < 32; j++) {
			right[j] ^= left[j];
			left[j] = swap[j];
		}
	}

	// left & right互换合并，进行IIP，输出
	for (i = 0; i < 32; i++) {
		temp[i] = right[i];
		temp[32 + i] = left[i];
	}
	for (i = 0; i < 64; i++)
		inBit[i] = temp[IIP_table[i]];

	Bit2Char(inBit, out);
}

// ----------------------------DES算法整体框架----------------------------
int file_rw(char *inFile, char *outFile, char *keyText, int isDecode) {
	FILE *in, *out;
	int count;
	Elem inBuffer[8], outBuffer[8], keyBuffer[8];
	int bitKey[64];
	int subKeys[16][48];

	// 打开文件
	in = fopen(inFile, "rb");
	out = fopen(outFile, "wb"); 
	if (in == NULL) {
		printf("There is no input_file\n");
		return 0;
	}
	if (out == NULL) {
		printf("Fail to create output_file\n");
		return 0;
	}

	// 先将8字节的密钥转换成64位的格式，再生成16个子密钥
	memcpy(keyBuffer, keyText, 8);
	Char2Bit(keyBuffer, bitKey);
	CreateSubKey(bitKey, subKeys);

	while (!feof(in)) {
		// 读入8字节. 若不足8字节，补足8字节
		count = fread(inBuffer, sizeof(char), 8, in);
		if (count > 0 && count < 8) 
			memset(inBuffer + count, '\0', 8 - count);	
		else if (count == 0)
			break;

		// 分组加密/解密
		CryptologyBlock(inBuffer, outBuffer, subKeys, isDecode);

		// 输出8字节结果
		fwrite(outBuffer, sizeof(char), 8, out);
	}

	fclose(in);
	fclose(out);
	return 1;
} 

int main() {
	char inText[64], outText[64], act[64];
	int isDecode;

	printf("Encrypt or Decrypt ? \n  e for Encrypt; d for Decrypt; \n  Enter : ");
	scanf("%s", act);
	switch (act[0]) {
		case 'e' :
			isDecode = 0;
			break;
		case 'd':
			isDecode = 1;
			break;
		default:
			printf("Wrong Input.\n ");
			getchar();
			return 0;
	}
	printf("Please enter the input_file's name: ");
	scanf("%s", inText);
	printf("Please enter the output_file's name: ");
	scanf("%s", outText);

	char key[8];
	printf("Please enter the 8-bit key:");
	scanf("%s", key);

	file_rw(inText, outText, key, isDecode);
	if (isDecode == 0)
		printf("Encrypt Finish...\n");
	else
		printf("Decoding Finish...\n");
	getchar();
	return 0;
}
```
--- 

## 五、编译运行结果
首先需要准备一个用于加密的文本文件，我创建了一个I_have_a_dream.txt的记事本文件，内容是Martin Luther King在1963年发表的I have a dream演讲原文，长度适中。然后就可以编译运行程序了，运行结果如下：


---
参考链接：https://www.jianshu.com/p/c44a8a1b7c38


  [1]: https://www.researchgate.net/profile/Muhammad_Mushtaq31/publication/321587376/figure/fig4/AS:568581112987648@1512571709096/Data-Encryption-Standard-DES-Algorithm.png
  [2]: https://upload.wikimedia.org/wikipedia/commons/thumb/0/06/DES-key-schedule.png/250px-DES-key-schedule.png
  [3]: https://upload.wikimedia.org/wikipedia/commons/thumb/2/25/Data_Encription_Standard_Flow_Diagram.svg/300px-Data_Encription_Standard_Flow_Diagram.svg.png
